# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Pj5Kr2oa8zXqMjhT5a2SPEna5VBfGwW
"""

!pip install streamlit ortools folium streamlit-folium

import streamlit as st
import pandas as pd
import folium
from streamlit_folium import st_folium
from ortools.constraint_solver import pywrapcp, routing_enums_pb2
from math import radians, sin, cos, sqrt, asin

# Funciones (mismas que en notebook)

def haversine(coord1, coord2):
    lon1, lat1 = coord1
    lon2, lat2 = coord2
    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat/2)**2 + cos(lat1)*cos(lat2)*sin(dlon/2)**2
    return 6371 * 2 * asin(sqrt(a))

def compute_distance_matrix(locations):
    return [[int(haversine(locations[i], locations[j]) * 1000) for j in range(len(locations))] for i in range(len(locations))]

def solve_vrp(locations, demands, num_vehicles, capacities, cost_per_km):
    distance_matrix = compute_distance_matrix(locations)
    manager = pywrapcp.RoutingIndexManager(len(distance_matrix), num_vehicles, 0)
    routing = pywrapcp.RoutingModel(manager)

    def distance_callback(from_idx, to_idx):
        return distance_matrix[manager.IndexToNode(from_idx)][manager.IndexToNode(to_idx)]

    transit_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_index)

    def demand_callback(index):
        return demands[manager.IndexToNode(index)]

    demand_index = routing.RegisterUnaryTransitCallback(demand_callback)
    routing.AddDimensionWithVehicleCapacity(
        demand_index,
        0,
        capacities,
        True,
        "Capacity"
    )

    params = pywrapcp.DefaultRoutingSearchParameters()
    params.first_solution_strategy = routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC

    solution = routing.SolveWithParameters(params)
    if not solution:
        return None

    routes = []
    for v in range(num_vehicles):
        idx = routing.Start(v)
        route = []
        dist = 0
        while not routing.IsEnd(idx):
            node = manager.IndexToNode(idx)
            route.append(node)
            next_idx = solution.Value(routing.NextVar(idx))
            dist += routing.GetArcCostForVehicle(idx, next_idx, v)
            idx = next_idx
        route.append(manager.IndexToNode(idx))
        routes.append({"vehicle": v, "route": route, "distance_km": dist / 1000, "cost": cost_per_km * (dist / 1000)})
    return routes

def show_map(routes, locations):
    m = folium.Map(location=locations[0], zoom_start=13)
    colors = ["blue", "green", "red", "purple", "orange"]
    for r in routes:
        points = [locations[i] for i in r["route"]]
        folium.PolyLine(points, color=colors[r["vehicle"] % len(colors)], weight=4).add_to(m)
        for i in r["route"]:
            folium.Marker(locations[i], popup=f"Cliente {i}").add_to(m)
    return m

# Streamlit app

st.title("ðŸšš Plataforma VRP con OR-Tools")

st.markdown("""
Ingrese los datos de los clientes, vehÃ­culos y costos para resolver el problema clÃ¡sico de ruteo de vehÃ­culos.
""")

clients_data = st.text_area(
    "Clientes (latitud,longitud,demanda), una por lÃ­nea:",
    "-33.4500,-70.6667,5\n-33.4550,-70.6700,3\n-33.4600,-70.6650,7\n-33.4650,-70.6600,4",
    height=150
)

num_vehicles = st.number_input("NÃºmero de vehÃ­culos:", min_value=1, max_value=10, value=2, step=1)
capacities_str = st.text_input("Capacidades de vehÃ­culos (separadas por coma):", "10,15")
cost_per_km = st.number_input("Costo por km recorrido:", min_value=0.0, value=2.5)

if st.button("Resolver VRP"):
    try:
        lines = clients_data.strip().split("\n")
        coords = []
        demands = []
        for line in lines:
            lat, lon, d = map(float, line.strip().split(","))
            coords.append((lat, lon))
            demands.append(int(d))

        capacities = list(map(int, capacities_str.split(",")))
        if len(capacities) != num_vehicles:
            st.error("El nÃºmero de capacidades debe coincidir con el nÃºmero de vehÃ­culos.")
        else:
            routes = solve_vrp(coords, demands, num_vehicles, capacities, cost_per_km)
            if not routes:
                st.error("No se encontrÃ³ soluciÃ³n. Revisa las capacidades y demandas.")
            else:
                for r in routes:
                    st.write(f"VehÃ­culo {r['vehicle']} -> Ruta: {r['route']}, Distancia: {r['distance_km']:.2f} km, Costo: ${r['cost']:.2f}")
                m = show_map(routes, coords)
                st_folium(m, width=700)
    except Exception as e:
        st.error(f"Error en los datos ingresados: {e}")